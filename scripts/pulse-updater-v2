#!/bin/bash
# Pulse Update Script v2 - Zero-downtime updates with health checks
# Usage: pulse-updater-v2 <version> <download_url>

set -e

VERSION="$1"
DOWNLOAD_URL="$2"
PULSE_DIR="/opt/pulse"
BINARY_PATH="/usr/local/bin/pulse"
BINARY_NEW="/usr/local/bin/pulse.new"
TEMP_DIR="/tmp/pulse-update-$$"
BACKUP_DIR="/opt/pulse/backups"
LOG_FILE="/tmp/pulse-updater.log"
TEST_PORT=7656
MAX_HEALTH_ATTEMPTS=30

# Logging function
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $*" >> "$LOG_FILE"
}

# Cleanup function
cleanup() {
    # Kill test instance if running
    if [ -n "$TEST_PID" ]; then
        kill $TEST_PID 2>/dev/null || true
    fi
    rm -rf "$TEMP_DIR"
    rm -f "$BINARY_NEW"
}
trap cleanup EXIT

# Validate arguments
if [ -z "$VERSION" ] || [ -z "$DOWNLOAD_URL" ]; then
    log "ERROR: Usage: pulse-updater-v2 <version> <download_url>"
    exit 1
fi

log "Starting zero-downtime update to version $VERSION"

# Create temp directory
mkdir -p "$TEMP_DIR"
cd "$TEMP_DIR"

# Download update
log "Downloading from $DOWNLOAD_URL"
if ! wget -q --timeout=60 "$DOWNLOAD_URL" -O update.tar.gz; then
    log "ERROR: Failed to download update"
    exit 1
fi

# Extract update
log "Extracting update package"
if ! tar -xzf update.tar.gz; then
    log "ERROR: Failed to extract update"
    exit 1
fi

# Find the binary
PULSE_BINARY=""
if [ -f "pulse" ]; then
    PULSE_BINARY="pulse"
elif [ -f "pulse-linux-amd64" ]; then
    PULSE_BINARY="pulse-linux-amd64"
else
    log "ERROR: No pulse binary found in update package"
    exit 1
fi

# Verify the binary is executable
if ! file "$PULSE_BINARY" | grep -q "executable"; then
    log "ERROR: Downloaded file is not a valid executable"
    exit 1
fi

# Copy new binary to test location
log "Preparing new binary for testing"
cp "$PULSE_BINARY" "$BINARY_NEW"
chmod 755 "$BINARY_NEW"
chown root:root "$BINARY_NEW"

# Start new version on test port
log "Starting new version on port $TEST_PORT for health check"
export PULSE_PORT=$TEST_PORT
export PULSE_DATA_DIR="$TEMP_DIR/data"
mkdir -p "$PULSE_DATA_DIR"

# Start in background and capture PID
$BINARY_NEW > "$TEMP_DIR/test.log" 2>&1 &
TEST_PID=$!

# Wait for service to start
log "Waiting for new version to start..."
HEALTH_ATTEMPTS=0
while [ $HEALTH_ATTEMPTS -lt $MAX_HEALTH_ATTEMPTS ]; do
    sleep 1
    
    # Check if process is still running
    if ! kill -0 $TEST_PID 2>/dev/null; then
        log "ERROR: New version crashed during startup"
        cat "$TEMP_DIR/test.log" >> "$LOG_FILE"
        exit 1
    fi
    
    # Check health endpoint
    if curl -s -f "http://localhost:$TEST_PORT/api/version" > /dev/null 2>&1; then
        NEW_VERSION=$(curl -s "http://localhost:$TEST_PORT/api/version" | grep -o '"version":"[^"]*"' | cut -d'"' -f4)
        log "New version $NEW_VERSION is healthy and responding"
        break
    fi
    
    HEALTH_ATTEMPTS=$((HEALTH_ATTEMPTS + 1))
done

if [ $HEALTH_ATTEMPTS -ge $MAX_HEALTH_ATTEMPTS ]; then
    log "ERROR: New version failed health check after $MAX_HEALTH_ATTEMPTS attempts"
    cat "$TEMP_DIR/test.log" >> "$LOG_FILE"
    exit 1
fi

# Kill test instance
log "Health check passed, stopping test instance"
kill $TEST_PID 2>/dev/null || true
wait $TEST_PID 2>/dev/null || true
TEST_PID=""

# Create backup of current version
log "Creating backup of current version"
mkdir -p "$BACKUP_DIR"
if [ -f "$BINARY_PATH" ]; then
    CURRENT_VERSION=$(cat "$PULSE_DIR/VERSION" 2>/dev/null || echo "unknown")
    cp "$BINARY_PATH" "$BACKUP_DIR/pulse-backup-${CURRENT_VERSION}-$(date +%Y%m%d-%H%M%S)"
    
    # Keep only last 5 backups
    ls -t "$BACKUP_DIR"/pulse-backup-* 2>/dev/null | tail -n +6 | xargs -r rm
fi

# Stop the current service
log "Stopping current pulse service"
systemctl stop pulse || true

# Install new binary (atomic move)
log "Installing new binary"
mv "$BINARY_NEW" "$BINARY_PATH"

# Update frontend if included
if [ -d "frontend-modern" ]; then
    log "Updating frontend files"
    rm -rf "$PULSE_DIR/frontend-modern.old"
    [ -d "$PULSE_DIR/frontend-modern" ] && mv "$PULSE_DIR/frontend-modern" "$PULSE_DIR/frontend-modern.old"
    cp -r frontend-modern "$PULSE_DIR/"
    chown -R pulse:pulse "$PULSE_DIR/frontend-modern" 2>/dev/null || true
fi

# Update VERSION file
echo "$VERSION" > "$PULSE_DIR/VERSION"
chown pulse:pulse "$PULSE_DIR/VERSION" 2>/dev/null || true

# Start the service with new version
log "Starting pulse service with new version"
if ! systemctl start pulse; then
    log "ERROR: Failed to start service with new version, attempting rollback"
    
    # Rollback
    LAST_BACKUP=$(ls -t "$BACKUP_DIR"/pulse-backup-* 2>/dev/null | head -1)
    if [ -n "$LAST_BACKUP" ]; then
        cp "$LAST_BACKUP" "$BINARY_PATH"
        chmod 755 "$BINARY_PATH"
        systemctl start pulse || true
        log "Rolled back to previous version"
    fi
    exit 1
fi

# Verify service is running with new version
sleep 2
if systemctl is-active --quiet pulse; then
    RUNNING_VERSION=$(curl -s "http://localhost:7655/api/version" 2>/dev/null | grep -o '"version":"[^"]*"' | cut -d'"' -f4 || echo "unknown")
    log "Update completed successfully. Running version: $RUNNING_VERSION"
    
    # Clean up old frontend backup after successful update
    rm -rf "$PULSE_DIR/frontend-modern.old"
else
    log "ERROR: Service failed to start after update"
    exit 1
fi

log "Zero-downtime update completed successfully"
exit 0